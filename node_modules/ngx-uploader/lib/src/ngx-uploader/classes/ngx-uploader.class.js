import { EventEmitter } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/from';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/map';
export var UploadStatus;
(function (UploadStatus) {
    UploadStatus[UploadStatus["Queue"] = 0] = "Queue";
    UploadStatus[UploadStatus["Uploading"] = 1] = "Uploading";
    UploadStatus[UploadStatus["Done"] = 2] = "Done";
    UploadStatus[UploadStatus["Canceled"] = 3] = "Canceled";
})(UploadStatus || (UploadStatus = {}));
export function humanizeBytes(bytes) {
    if (bytes === 0) {
        return '0 Byte';
    }
    var k = 1024;
    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
    var i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
var NgUploaderService = (function () {
    function NgUploaderService() {
        this.files = [];
        this.serviceEvents = new EventEmitter();
    }
    NgUploaderService.prototype.handleFiles = function (incomingFiles) {
        var _this = this;
        (_a = this.files).push.apply(_a, [].map.call(incomingFiles, function (file, i) {
            var uploadFile = {
                fileIndex: i,
                id: _this.generateId(),
                name: file.name,
                size: file.size,
                type: file.type,
                form: new FormData(),
                progress: {
                    status: UploadStatus.Queue,
                    data: {
                        percentage: 0,
                        speed: 0,
                        speedHuman: humanizeBytes(0) + "/s",
                        startTime: null,
                        endTime: null,
                        eta: null,
                        etaHuman: null
                    }
                },
                lastModifiedDate: file.lastModifiedDate,
                sub: undefined,
                nativeFile: file
            };
            i = i + 1;
            _this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });
            return uploadFile;
        }));
        this.serviceEvents.emit({ type: 'allAddedToQueue' });
        var _a;
    };
    NgUploaderService.prototype.initInputEvents = function (input) {
        var _this = this;
        input.subscribe(function (event) {
            switch (event.type) {
                case 'uploadFile':
                    var uploadFileIndex = _this.files.findIndex(function (file) { return file === event.file; });
                    if (uploadFileIndex !== -1 && event.file) {
                        _this.files[uploadFileIndex].sub = _this.uploadFile(event.file, event).subscribe(function (data) {
                            _this.serviceEvents.emit(data);
                        });
                    }
                    break;
                case 'uploadAll':
                    var concurrency = typeof event.concurrency !== 'undefined' && event.concurrency > 0 ? event.concurrency : Number.POSITIVE_INFINITY;
                    var files = _this.files.filter(function (file) { return file.progress.status === UploadStatus.Queue; });
                    if (!files.length) {
                        return;
                    }
                    Observable.of.apply(Observable, files).mergeMap(function (file) {
                        return _this.uploadFile(file, event);
                    }, concurrency)
                        .subscribe(function (data) {
                        _this.serviceEvents.emit(data);
                    });
                    break;
                case 'cancel':
                    var id_1 = event.id || null;
                    if (!id_1) {
                        return;
                    }
                    var index = _this.files.findIndex(function (file) { return file.id === id_1; });
                    if (index !== -1) {
                        if (_this.files[index].sub) {
                            _this.files[index].sub.unsubscribe();
                        }
                        _this.serviceEvents.emit({ type: 'cancelled', file: _this.files[index] });
                        _this.files[index].progress.status = UploadStatus.Canceled;
                    }
                    break;
                case 'cancelAll':
                    _this.files.forEach(function (file) {
                        if (file.sub) {
                            file.sub.unsubscribe();
                        }
                        file.progress.status = UploadStatus.Canceled;
                        _this.serviceEvents.emit({ type: 'cancelled', file: file });
                    });
                    break;
                case 'remove':
                    if (!event.id) {
                        return;
                    }
                    var i = _this.files.findIndex(function (file) { return file.id === event.id; });
                    if (i !== -1) {
                        var file = _this.files[i];
                        _this.files.splice(i, 1);
                        _this.serviceEvents.emit({ type: 'removed', file: file });
                    }
                    break;
                case 'removeAll':
                    if (_this.files.length) {
                        _this.files = [];
                        _this.serviceEvents.emit({ type: 'removedAll' });
                    }
                    break;
            }
        });
    };
    NgUploaderService.prototype.uploadFile = function (file, event) {
        var _this = this;
        return new Observable(function (observer) {
            var url = event.url || '';
            var method = event.method || 'POST';
            var data = event.data || {};
            var headers = event.headers || {};
            var reader = new FileReader();
            var xhr = new XMLHttpRequest();
            var time = new Date().getTime();
            var progressStartTime = (file.progress.data && file.progress.data.startTime) || time;
            var speed = 0;
            var eta = null;
            xhr.upload.addEventListener('progress', function (e) {
                if (e.lengthComputable) {
                    var percentage = Math.round((e.loaded * 100) / e.total);
                    var diff = new Date().getTime() - time;
                    speed = Math.round(e.loaded / diff * 1000);
                    progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();
                    eta = Math.ceil((e.total - e.loaded) / speed);
                    file.progress = {
                        status: UploadStatus.Uploading,
                        data: {
                            percentage: percentage,
                            speed: speed,
                            speedHuman: humanizeBytes(speed) + "/s",
                            startTime: progressStartTime,
                            endTime: null,
                            eta: eta,
                            etaHuman: _this.secondsToHuman(eta)
                        }
                    };
                    observer.next({ type: 'uploading', file: file });
                }
            }, false);
            xhr.upload.addEventListener('error', function (e) {
                observer.error(e);
                observer.complete();
            });
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    var speedAverage = Math.round(file.size / (new Date().getTime() - progressStartTime) * 1000);
                    file.progress = {
                        status: UploadStatus.Done,
                        data: {
                            percentage: 100,
                            speed: speedAverage,
                            speedHuman: humanizeBytes(speedAverage) + "/s",
                            startTime: progressStartTime,
                            endTime: new Date().getTime(),
                            eta: eta,
                            etaHuman: _this.secondsToHuman(eta || 0)
                        }
                    };
                    file.responseStatus = xhr.status;
                    try {
                        file.response = JSON.parse(xhr.response);
                    }
                    catch (e) {
                        file.response = xhr.response;
                    }
                    observer.next({ type: 'done', file: file });
                    observer.complete();
                }
            };
            xhr.open(method, url, true);
            xhr.withCredentials = event.withCredentials ? true : false;
            try {
                var uploadFile_1 = file.nativeFile;
                var uploadIndex = _this.files.findIndex(function (file) { return file.nativeFile === uploadFile_1; });
                if (_this.files[uploadIndex].progress.status === UploadStatus.Canceled) {
                    observer.complete();
                }
                file.form.append(event.fieldName || 'file', uploadFile_1, uploadFile_1.name);
                Object.keys(data).forEach(function (key) { return file.form.append(key, data[key]); });
                Object.keys(headers).forEach(function (key) { return xhr.setRequestHeader(key, headers[key]); });
                _this.serviceEvents.emit({ type: 'start', file: file });
                xhr.send(file.form);
            }
            catch (e) {
                observer.complete();
            }
            return function () {
                xhr.abort();
                reader.abort();
            };
        });
    };
    NgUploaderService.prototype.secondsToHuman = function (sec) {
        return new Date(sec * 1000).toISOString().substr(11, 8);
    };
    NgUploaderService.prototype.generateId = function () {
        return Math.random().toString(36).substring(7);
    };
    return NgUploaderService;
}());
export { NgUploaderService };
